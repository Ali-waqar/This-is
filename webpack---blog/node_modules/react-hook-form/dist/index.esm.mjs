import _asyncToGenerator from "/vercel/path0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js";
import _defineProperty from "/vercel/path0/node_modules/@babel/runtime/helpers/esm/defineProperty.js";
import _slicedToArray from "/vercel/path0/node_modules/@babel/runtime/helpers/esm/slicedToArray.js";
import _toConsumableArray from "/vercel/path0/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js";
import _regeneratorRuntime from "/vercel/path0/node_modules/@babel/runtime/regenerator/index.js";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import React from 'react';

var isCheckBoxInput = function isCheckBoxInput(element) {
  return element.type === 'checkbox';
};

var isDateObject = function isDateObject(data) {
  return data instanceof Date;
};

var isNullOrUndefined = function isNullOrUndefined(value) {
  return value == null;
};

var isObjectType = function isObjectType(value) {
  return typeof value === 'object';
};

var isObject = function isObject(value) {
  return !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
};

var getEventValue = function getEventValue(event) {
  return isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
};

var getNodeParentName = function getNodeParentName(name) {
  return name.substring(0, name.search(/.\d/)) || name;
};

var isNameInFieldArray = function isNameInFieldArray(names, name) {
  return _toConsumableArray(names).some(function (current) {
    return getNodeParentName(name) === current;
  });
};

var compact = function compact(value) {
  return (value || []).filter(Boolean);
};

var isUndefined = function isUndefined(val) {
  return val === undefined;
};

var get = function get(obj, path, defaultValue) {
  if (isObject(obj) && path) {
    var result = compact(path.split(/[,[\].]+?/)).reduce(function (result, key) {
      return isNullOrUndefined(result) ? result : result[key];
    }, obj);
    return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;
  }

  return undefined;
};

var EVENTS = {
  BLUR: 'blur',
  CHANGE: 'change'
};
var VALIDATION_MODE = {
  onBlur: 'onBlur',
  onChange: 'onChange',
  onSubmit: 'onSubmit',
  onTouched: 'onTouched',
  all: 'all'
};
var INPUT_VALIDATION_RULES = {
  max: 'max',
  min: 'min',
  maxLength: 'maxLength',
  minLength: 'minLength',
  pattern: 'pattern',
  required: 'required',
  validate: 'validate'
};

var omit = function omit(source, key) {
  var copy = Object.assign({}, source);
  delete copy[key];
  return copy;
};

var HookFormContext = React.createContext(null);

var useFormContext = function useFormContext() {
  return React.useContext(HookFormContext);
};

var FormProvider = function FormProvider(props) {
  return React.createElement(HookFormContext.Provider, {
    value: omit(props, 'children')
  }, props.children);
};

var getProxyFormState = function getProxyFormState(formState, _proxyFormState, localProxyFormState) {
  var isRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  function createGetter(prop) {
    return function () {
      if (prop in formState) {
        if (_proxyFormState[prop] !== VALIDATION_MODE.all) {
          _proxyFormState[prop] = !isRoot || VALIDATION_MODE.all;
        }

        localProxyFormState && (localProxyFormState[prop] = true);
        return formState[prop];
      }

      return undefined;
    };
  }

  var result = {};

  for (var key in formState) {
    Object.defineProperty(result, key, {
      get: createGetter(key)
    });
  }

  return result;
};

var isEmptyObject = function isEmptyObject(value) {
  return isObject(value) && !Object.keys(value).length;
};

var shouldRenderFormState = function shouldRenderFormState(formStateData, _proxyFormState, isRoot) {
  var formState = omit(formStateData, 'name');
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find(function (key) {
    return _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all);
  });
};

var convertToArrayPayload = function convertToArrayPayload(value) {
  return Array.isArray(value) ? value : [value];
};

var shouldSubscribeByName = function shouldSubscribeByName(name, signalName, exact) {
  return exact && signalName ? name === signalName : !name || !signalName || name === signalName || convertToArrayPayload(name).some(function (currentName) {
    return currentName && (currentName.startsWith(signalName) || signalName.startsWith(currentName));
  });
};

function useSubscribe(props) {
  var _props = React.useRef(props);

  _props.current = props;
  React.useEffect(function () {
    var tearDown = function tearDown(subscription) {
      if (subscription) {
        subscription.unsubscribe();
      }
    };

    var subscription = !props.disabled && _props.current.subject.subscribe({
      next: _props.current.callback
    });

    return function () {
      return tearDown(subscription);
    };
  }, [props.disabled]);
}

function useFormState(props) {
  var methods = useFormContext();

  var _ref = props || {},
      _ref$control = _ref.control,
      control = _ref$control === void 0 ? methods.control : _ref$control,
      disabled = _ref.disabled,
      name = _ref.name,
      exact = _ref.exact;

  var _React$useState = React.useState(control._formState),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      formState = _React$useState2[0],
      updateFormState = _React$useState2[1];

  var _localProxyFormState = React.useRef({
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });

  var _name = React.useRef(name);

  _name.current = name;
  useSubscribe({
    disabled: disabled,
    callback: function callback(value) {
      return shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current) && updateFormState(Object.assign(Object.assign({}, control._formState), value));
    },
    subject: control._subjects.state
  });
  return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);
}

var isString = function isString(value) {
  return typeof value === 'string';
};

var generateWatchOutput = function generateWatchOutput(names, _names, formValues, isGlobal) {
  var isArray = Array.isArray(names);

  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names);
  }

  if (isArray) {
    return names.map(function (fieldName) {
      return isGlobal && _names.watch.add(fieldName), get(formValues, fieldName);
    });
  }

  isGlobal && (_names.watchAll = true);
  return formValues;
};

var isFunction = function isFunction(value) {
  return typeof value === 'function';
};

var objectHasFunction = function objectHasFunction(data) {
  for (var key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }

  return false;
};

function useWatch(props) {
  var methods = useFormContext();

  var _ref2 = props || {},
      _ref2$control = _ref2.control,
      control = _ref2$control === void 0 ? methods.control : _ref2$control,
      name = _ref2.name,
      defaultValue = _ref2.defaultValue,
      disabled = _ref2.disabled,
      exact = _ref2.exact;

  var _name = React.useRef(name);

  _name.current = name;
  useSubscribe({
    disabled: disabled,
    subject: control._subjects.watch,
    callback: function callback(formState) {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        var fieldValues = generateWatchOutput(_name.current, control._names, formState.values || control._formValues);
        updateValue(isUndefined(_name.current) || isObject(fieldValues) && !objectHasFunction(fieldValues) ? Object.assign({}, fieldValues) : Array.isArray(fieldValues) ? _toConsumableArray(fieldValues) : isUndefined(fieldValues) ? defaultValue : fieldValues);
      }
    }
  });

  var _React$useState3 = React.useState(isUndefined(defaultValue) ? control._getWatch(name) : defaultValue),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      value = _React$useState4[0],
      updateValue = _React$useState4[1];

  React.useEffect(function () {
    control._removeUnmounted();
  });
  return value;
}

function useController(props) {
  var methods = useFormContext();
  var name = props.name,
      _props$control = props.control,
      control = _props$control === void 0 ? methods.control : _props$control,
      shouldUnregister = props.shouldUnregister;
  var isArrayField = isNameInFieldArray(control._names.array, name);
  var value = useWatch({
    control: control,
    name: name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: !isArrayField
  });
  var formState = useFormState({
    control: control,
    name: name
  });

  var _name = React.useRef(name);

  _name.current = name;
  var registerProps = control.register(name, Object.assign(Object.assign({}, props.rules), {
    value: value
  }));
  React.useEffect(function () {
    var updateMounted = function updateMounted(name, value) {
      var field = get(control._fields, name);

      if (field) {
        field._f.mount = value;
      }
    };

    updateMounted(name, true);
    return function () {
      var _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;

      isArrayField ? _shouldUnregisterField && !control._stateFlags.action : _shouldUnregisterField ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  return {
    field: {
      onChange: function onChange(event) {
        registerProps.onChange({
          target: {
            value: getEventValue(event),
            name: name
          },
          type: EVENTS.CHANGE
        });
      },
      onBlur: function onBlur() {
        registerProps.onBlur({
          target: {
            value: get(control._formValues, name),
            name: name
          },
          type: EVENTS.BLUR
        });
      },
      name: name,
      value: value,
      ref: function ref(elm) {
        var field = get(control._fields, name);

        if (elm && field && elm.focus) {
          field._f.ref = {
            focus: function focus() {
              return elm.focus();
            },
            setCustomValidity: function setCustomValidity(message) {
              return elm.setCustomValidity(message);
            },
            reportValidity: function reportValidity() {
              return elm.reportValidity();
            }
          };
        }
      }
    },
    formState: formState,
    fieldState: {
      invalid: !!get(formState.errors, name),
      isDirty: !!get(formState.dirtyFields, name),
      isTouched: !!get(formState.touchedFields, name),
      error: get(formState.errors, name)
    }
  };
}

var Controller = function Controller(props) {
  return props.render(useController(props));
};

var appendErrors = function appendErrors(name, validateAllFieldCriteria, errors, type, message) {
  return validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {
    types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), _defineProperty({}, type, message || true))
  }) : {};
};

var isKey = function isKey(value) {
  return /^\w*$/.test(value);
};

var stringToPath = function stringToPath(input) {
  return compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));
};

function set(object, path, value) {
  var index = -1;
  var tempPath = isKey(path) ? [path] : stringToPath(path);
  var length = tempPath.length;
  var lastIndex = length - 1;

  while (++index < length) {
    var key = tempPath[index];
    var newValue = value;

    if (index !== lastIndex) {
      var objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }

    object[key] = newValue;
    object = object[key];
  }

  return object;
}

var focusFieldBy = function focusFieldBy(fields, callback, fieldsNames) {
  var _iterator = _createForOfIteratorHelper(fieldsNames || Object.keys(fields)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      var field = get(fields, key);

      if (field) {
        var _f = field._f;
        var current = omit(field, '_f');

        if (_f && callback(_f.name)) {
          if (_f.ref.focus && isUndefined(_f.ref.focus())) {
            break;
          } else if (_f.refs) {
            _f.refs[0].focus();

            break;
          }
        } else if (isObject(current)) {
          focusFieldBy(current, callback);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

var getFocusFieldName = function getFocusFieldName(name, index) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || "".concat(name, ".").concat(isUndefined(options.focusIndex) ? index : options.focusIndex, ".") : '';
};

var isWatched = function isWatched(name, _names, isBlurEvent) {
  return !isBlurEvent && (_names.watchAll || _names.watch.has(name) || _toConsumableArray(_names.watch).some(function (watchName) {
    return name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length));
  }));
};

var mapCurrentIds = function mapCurrentIds(values, _fieldIds, keyName) {
  return values.map(function (value, index) {
    var output = _fieldIds.current[index];
    return Object.assign(Object.assign({}, value), output ? _defineProperty({}, keyName, output[keyName]) : {});
  });
};

var generateId = function generateId() {
  var d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (Math.random() * 16 + d) % 16 | 0;
    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
};

var mapIds = function mapIds() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var keyName = arguments.length > 1 ? arguments[1] : undefined;
  return values.map(function (value) {
    return Object.assign(Object.assign({}, value[keyName] ? {} : _defineProperty({}, keyName, generateId())), value);
  });
};

function append(data, value) {
  return [].concat(_toConsumableArray(convertToArrayPayload(data)), _toConsumableArray(convertToArrayPayload(value)));
}

function cloneObject(data) {
  var copy;
  var isArray = Array.isArray(data);

  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (isArray || isObject(data)) {
    copy = isArray ? [] : {};

    for (var key in data) {
      if (isFunction(data[key])) {
        copy = data;
        break;
      }

      copy[key] = cloneObject(data[key]);
    }
  } else {
    return data;
  }

  return copy;
}

var fillEmptyArray = function fillEmptyArray(value) {
  return Array.isArray(value) ? value.map(function () {
    return undefined;
  }) : undefined;
};

function insert(data, index, value) {
  return [].concat(_toConsumableArray(data.slice(0, index)), _toConsumableArray(convertToArrayPayload(value)), _toConsumableArray(data.slice(index)));
}

var moveArrayAt = function moveArrayAt(data, from, to) {
  if (Array.isArray(data)) {
    if (isUndefined(data[to])) {
      data[to] = undefined;
    }

    data.splice(to, 0, data.splice(from, 1)[0]);
    return data;
  }

  return [];
};

var omitKeys = function omitKeys(fields, keyName) {
  return fields.map(function () {
    var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return omit(field, keyName);
  });
};

function prepend(data, value) {
  return [].concat(_toConsumableArray(convertToArrayPayload(value)), _toConsumableArray(convertToArrayPayload(data)));
}

function removeAtIndexes(data, indexes) {
  var i = 0;

  var temp = _toConsumableArray(data);

  var _iterator2 = _createForOfIteratorHelper(indexes),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var index = _step2.value;
      temp.splice(index - i, 1);
      i++;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return compact(temp).length ? temp : [];
}

var removeArrayAt = function removeArrayAt(data, index) {
  return isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort(function (a, b) {
    return a - b;
  }));
};

var swapArrayAt = function swapArrayAt(data, indexA, indexB) {
  data[indexA] = [data[indexB], data[indexB] = data[indexA]][0];
};

var updateAt = function updateAt(fieldValues, index, value) {
  fieldValues[index] = value;
  return fieldValues;
};

var useFieldArray = function useFieldArray(props) {
  var methods = useFormContext();
  var _props$control2 = props.control,
      control = _props$control2 === void 0 ? methods.control : _props$control2,
      name = props.name,
      _props$keyName = props.keyName,
      keyName = _props$keyName === void 0 ? 'id' : _props$keyName,
      shouldUnregister = props.shouldUnregister;

  var _React$useState5 = React.useState(mapIds(control._getFieldArray(name), keyName)),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      fields = _React$useState6[0],
      setFields = _React$useState6[1];

  var _fieldIds = React.useRef(fields);

  var _name = React.useRef(name);

  var _actioned = React.useRef(false);

  _name.current = name;
  _fieldIds.current = fields;

  control._names.array.add(name);

  useSubscribe({
    callback: function callback(_ref5) {
      var values = _ref5.values,
          fieldArrayName = _ref5.name;

      if (fieldArrayName === _name.current || !fieldArrayName) {
        setFields(mapIds(get(values, _name.current), keyName));
      }
    },
    subject: control._subjects.array
  });
  var updateValues = React.useCallback(function (updatedFieldArrayValuesWithKey) {
    var updatedFieldArrayValues = omitKeys(updatedFieldArrayValuesWithKey, keyName);
    _actioned.current = true;
    set(control._formValues, name, updatedFieldArrayValues);
    return updatedFieldArrayValues;
  }, [control, name, keyName]);

  var append$1 = function append$1(value, options) {
    var appendValue = convertToArrayPayload(cloneObject(value));
    var updatedFieldArrayValuesWithKey = append(mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName), mapIds(appendValue, keyName));
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    control._names.focus = getFocusFieldName(name, fieldArrayValues.length - 1, options);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, append, {
      argA: fillEmptyArray(value)
    }, fieldArrayValues);
  };

  var prepend$1 = function prepend$1(value, options) {
    var updatedFieldArrayValuesWithKey = prepend(mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName), mapIds(convertToArrayPayload(cloneObject(value)), keyName));
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    control._names.focus = getFocusFieldName(name, 0, options);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, prepend, {
      argA: fillEmptyArray(value)
    }, fieldArrayValues);
  };

  var remove = function remove(index) {
    var updatedFieldArrayValuesWithKey = removeArrayAt(mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName), index);
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, removeArrayAt, {
      argA: index
    }, fieldArrayValues);
  };

  var insert$1 = function insert$1(index, value, options) {
    var updatedFieldArrayValuesWithKey = insert(mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName), index, mapIds(convertToArrayPayload(cloneObject(value)), keyName));
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    control._names.focus = getFocusFieldName(name, index, options);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, insert, {
      argA: index,
      argB: fillEmptyArray(value)
    }, fieldArrayValues);
  };

  var swap = function swap(indexA, indexB) {
    var updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName);
    swapArrayAt(updatedFieldArrayValuesWithKey, indexA, indexB);
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, fieldArrayValues, false);
  };

  var move = function move(from, to) {
    var updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName);
    moveArrayAt(updatedFieldArrayValuesWithKey, from, to);
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, moveArrayAt, {
      argA: from,
      argB: to
    }, fieldArrayValues, false);
  };

  var update = function update(index, value) {
    var updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArray(name), _fieldIds, keyName);
    var updatedFieldArrayValues = updateAt(updatedFieldArrayValuesWithKey, index, value);
    _fieldIds.current = mapIds(updatedFieldArrayValues, keyName);
    var fieldArrayValues = updateValues(_fieldIds.current);
    setFields(_fieldIds.current);

    control._updateFieldArray(name, updateAt, {
      argA: index,
      argB: value
    }, fieldArrayValues, true, false, false);
  };

  var replace = function replace(value) {
    var updatedFieldArrayValuesWithKey = mapIds(convertToArrayPayload(value), keyName);
    var fieldArrayValues = updateValues(updatedFieldArrayValuesWithKey);
    setFields(updatedFieldArrayValuesWithKey);

    control._updateFieldArray(name, function () {
      return updatedFieldArrayValuesWithKey;
    }, {}, fieldArrayValues, true, false, false);
  };

  React.useEffect(function () {
    control._stateFlags.action = false;
    isWatched(name, control._names) && control._subjects.state.next({});

    if (_actioned.current) {
      control._executeSchema([name]).then(function (result) {
        var error = get(result.errors, name);

        if (error && error.type && !get(control._formState.errors, name)) {
          set(control._formState.errors, name, error);

          control._subjects.state.next({
            errors: control._formState.errors
          });
        }
      });
    }

    control._subjects.watch.next({
      name: name,
      values: control._formValues
    });

    control._names.focus && focusFieldBy(control._fields, function (key) {
      return key.startsWith(control._names.focus);
    });
    control._names.focus = '';
    control._proxyFormState.isValid && control._updateValid();
  }, [fields, name, control, keyName]);
  React.useEffect(function () {
    !get(control._formValues, name) && set(control._formValues, name, []);
    return function () {
      if (control._options.shouldUnregister || shouldUnregister) {
        control.unregister(name);
      }
    };
  }, [name, control, keyName, shouldUnregister]);
  return {
    swap: React.useCallback(swap, [updateValues, name, control, keyName]),
    move: React.useCallback(move, [updateValues, name, control, keyName]),
    prepend: React.useCallback(prepend$1, [updateValues, name, control, keyName]),
    append: React.useCallback(append$1, [updateValues, name, control, keyName]),
    remove: React.useCallback(remove, [updateValues, name, control, keyName]),
    insert: React.useCallback(insert$1, [updateValues, name, control, keyName]),
    update: React.useCallback(update, [updateValues, name, control, keyName]),
    replace: React.useCallback(replace, [updateValues, name, control, keyName]),
    fields: fields
  };
};

function createSubject() {
  var _observers = [];

  var next = function next(value) {
    var _iterator3 = _createForOfIteratorHelper(_observers),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var observer = _step3.value;
        observer.next(value);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  };

  var subscribe = function subscribe(observer) {
    _observers.push(observer);

    return {
      unsubscribe: function unsubscribe() {
        _observers = _observers.filter(function (o) {
          return o !== observer;
        });
      }
    };
  };

  var unsubscribe = function unsubscribe() {
    _observers = [];
  };

  return {
    get observers() {
      return _observers;
    },

    next: next,
    subscribe: subscribe,
    unsubscribe: unsubscribe
  };
}

var isPrimitive = function isPrimitive(value) {
  return isNullOrUndefined(value) || !isObjectType(value);
};

function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }

  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }

  var keys1 = Object.keys(object1);
  var keys2 = Object.keys(object2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (var _i = 0, _keys = keys1; _i < _keys.length; _i++) {
    var key = _keys[_i];
    var val1 = object1[key];

    if (!keys2.includes(key)) {
      return false;
    }

    if (key !== 'ref') {
      var val2 = object2[key];

      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }

  return true;
}

var getValidationModes = function getValidationModes(mode) {
  return {
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
    isOnAll: mode === VALIDATION_MODE.all,
    isOnTouch: mode === VALIDATION_MODE.onTouched
  };
};

var isBoolean = function isBoolean(value) {
  return typeof value === 'boolean';
};

var isFileInput = function isFileInput(element) {
  return element.type === 'file';
};

var isHTMLElement = function isHTMLElement(value) {
  return value instanceof HTMLElement;
};

var isMultipleSelect = function isMultipleSelect(element) {
  return element.type === "select-multiple";
};

var isRadioInput = function isRadioInput(element) {
  return element.type === 'radio';
};

var isRadioOrCheckbox = function isRadioOrCheckbox(ref) {
  return isRadioInput(ref) || isCheckBoxInput(ref);
};

var isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';

var live = function live(ref) {
  return isHTMLElement(ref) && document.contains(ref);
};

function baseGet(object, updatePath) {
  var length = updatePath.slice(0, -1).length;
  var index = 0;

  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }

  return object;
}

function unset(object, path) {
  var updatePath = isKey(path) ? [path] : stringToPath(path);
  var childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);
  var key = updatePath[updatePath.length - 1];
  var previousObjRef;

  if (childObject) {
    delete childObject[key];
  }

  for (var k = 0; k < updatePath.slice(0, -1).length; k++) {
    var index = -1;
    var objectRef = void 0;
    var currentPaths = updatePath.slice(0, -(k + 1));
    var currentPathsLength = currentPaths.length - 1;

    if (k > 0) {
      previousObjRef = object;
    }

    while (++index < currentPaths.length) {
      var item = currentPaths[index];
      objectRef = objectRef ? objectRef[item] : object[item];

      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(function (data) {
        return isObject(data) && !isEmptyObject(data) || isBoolean(data);
      }).length)) {
        previousObjRef ? delete previousObjRef[item] : delete object[item];
      }

      previousObjRef = objectRef;
    }
  }

  return object;
}

function markFieldsDirty(data) {
  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var isParentNodeArray = Array.isArray(data);

  if (isObject(data) || isParentNodeArray) {
    for (var key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }

  return fields;
}

function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  var isParentNodeArray = Array.isArray(data);

  if (isObject(data) || isParentNodeArray) {
    for (var key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : Object.assign({}, markFieldsDirty(data[key]));
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }

  return dirtyFieldsFromValues;
}

var getDirtyFields = function getDirtyFields(defaultValues, formValues) {
  return getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
};

var defaultResult = {
  value: false,
  isValid: false
};
var validResult = {
  value: true,
  isValid: true
};

var getCheckboxValue = function getCheckboxValue(options) {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      var values = options.filter(function (option) {
        return option && option.checked && !option.disabled;
      }).map(function (option) {
        return option.value;
      });
      return {
        value: values,
        isValid: !!values.length
      };
    }

    return options[0].checked && !options[0].disabled ? // @ts-expect-error expected to work in the browser
    options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {
      value: options[0].value,
      isValid: true
    } : validResult : defaultResult;
  }

  return defaultResult;
};

var getFieldValueAs = function getFieldValueAs(value, _ref6) {
  var valueAsNumber = _ref6.valueAsNumber,
      valueAsDate = _ref6.valueAsDate,
      setValueAs = _ref6.setValueAs;
  return isUndefined(value) ? value : valueAsNumber ? value === '' ? NaN : +value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
};

var defaultReturn = {
  isValid: false,
  value: null
};

var getRadioValue = function getRadioValue(options) {
  return Array.isArray(options) ? options.reduce(function (previous, option) {
    return option && option.checked && !option.disabled ? {
      isValid: true,
      value: option.value
    } : previous;
  }, defaultReturn) : defaultReturn;
};

function getFieldValue(_f) {
  var ref = _f.ref;

  if (_f.refs ? _f.refs.every(function (ref) {
    return ref.disabled;
  }) : ref.disabled) {
    return;
  }

  if (isFileInput(ref)) {
    return ref.files;
  }

  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }

  if (isMultipleSelect(ref)) {
    return _toConsumableArray(ref.selectedOptions).map(function (_ref7) {
      var value = _ref7.value;
      return value;
    });
  }

  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }

  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}

var getResolverOptions = function getResolverOptions(fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) {
  var fields = {};

  var _iterator4 = _createForOfIteratorHelper(fieldsNames),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var name = _step4.value;
      var field = get(_fields, name);
      field && set(fields, name, field._f);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return {
    criteriaMode: criteriaMode,
    names: _toConsumableArray(fieldsNames),
    fields: fields,
    shouldUseNativeValidation: shouldUseNativeValidation
  };
};

var isRegex = function isRegex(value) {
  return value instanceof RegExp;
};

var getRuleValue = function getRuleValue(rule) {
  return isUndefined(rule) ? undefined : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
};

var hasValidation = function hasValidation(options) {
  return options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
};

function schemaErrorLookup(errors, _fields, name) {
  var error = get(errors, name);

  if (error || isKey(name)) {
    return {
      error: error,
      name: name
    };
  }

  var names = name.split('.');

  while (names.length) {
    var fieldName = names.join('.');
    var field = get(_fields, fieldName);
    var foundError = get(errors, fieldName);

    if (field && !Array.isArray(field) && name !== fieldName) {
      return {
        name: name
      };
    }

    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }

    names.pop();
  }

  return {
    name: name
  };
}

var skipValidation = function skipValidation(isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }

  return true;
};

var unsetEmptyArray = function unsetEmptyArray(ref, name) {
  return !compact(get(ref, name)).length && unset(ref, name);
};

var isMessage = function isMessage(value) {
  return isString(value) || React.isValidElement(value);
};

function getValidateError(result, ref) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';

  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type: type,
      message: isMessage(result) ? result : '',
      ref: ref
    };
  }
}

var getValueAndMessage = function getValueAndMessage(validationData) {
  return isObject(validationData) && !isRegex(validationData) ? validationData : {
    value: validationData,
    message: ''
  };
};

var validateField = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation) {
    var _field$_f, ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, inputRef, setCustomValidity, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref9, value, message, exceedMax, exceedMin, maxOutput, minOutput, valueNumber, valueDate, maxLengthOutput, minLengthOutput, _exceedMax, _exceedMin, _getValueAndMessage, patternValue, _message, result, validateError, validationResult, key, _validateError;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _field$_f = field._f, ref = _field$_f.ref, refs = _field$_f.refs, required = _field$_f.required, maxLength = _field$_f.maxLength, minLength = _field$_f.minLength, min = _field$_f.min, max = _field$_f.max, pattern = _field$_f.pattern, validate = _field$_f.validate, name = _field$_f.name, valueAsNumber = _field$_f.valueAsNumber, mount = _field$_f.mount, disabled = _field$_f.disabled;

            if (!(!mount || disabled)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", {});

          case 3:
            inputRef = refs ? refs[0] : ref;

            setCustomValidity = function setCustomValidity(message) {
              if (shouldUseNativeValidation && inputRef.reportValidity) {
                inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');
                inputRef.reportValidity();
              }
            };

            error = {};
            isRadio = isRadioInput(ref);
            isCheckBox = isCheckBoxInput(ref);
            isRadioOrCheckbox = isRadio || isCheckBox;
            isEmpty = (valueAsNumber || isFileInput(ref)) && !ref.value || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;
            appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);

            getMinMaxMessage = function getMinMaxMessage(exceedMax, maxLengthMessage, minLengthMessage) {
              var maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;
              var minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;
              var message = exceedMax ? maxLengthMessage : minLengthMessage;
              error[name] = Object.assign({
                type: exceedMax ? maxType : minType,
                message: message,
                ref: ref
              }, appendErrorsCurry(exceedMax ? maxType : minType, message));
            };

            if (!(required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid))) {
              _context.next = 19;
              break;
            }

            _ref9 = isMessage(required) ? {
              value: !!required,
              message: required
            } : getValueAndMessage(required), value = _ref9.value, message = _ref9.message;

            if (!value) {
              _context.next = 19;
              break;
            }

            error[name] = Object.assign({
              type: INPUT_VALIDATION_RULES.required,
              message: message,
              ref: inputRef
            }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));

            if (validateAllFieldCriteria) {
              _context.next = 19;
              break;
            }

            setCustomValidity(message);
            return _context.abrupt("return", error);

          case 19:
            if (!(!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max)))) {
              _context.next = 28;
              break;
            }

            maxOutput = getValueAndMessage(max);
            minOutput = getValueAndMessage(min);

            if (!isNaN(inputValue)) {
              valueNumber = ref.valueAsNumber || parseFloat(inputValue);

              if (!isNullOrUndefined(maxOutput.value)) {
                exceedMax = valueNumber > maxOutput.value;
              }

              if (!isNullOrUndefined(minOutput.value)) {
                exceedMin = valueNumber < minOutput.value;
              }
            } else {
              valueDate = ref.valueAsDate || new Date(inputValue);

              if (isString(maxOutput.value)) {
                exceedMax = valueDate > new Date(maxOutput.value);
              }

              if (isString(minOutput.value)) {
                exceedMin = valueDate < new Date(minOutput.value);
              }
            }

            if (!(exceedMax || exceedMin)) {
              _context.next = 28;
              break;
            }

            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);

            if (validateAllFieldCriteria) {
              _context.next = 28;
              break;
            }

            setCustomValidity(error[name].message);
            return _context.abrupt("return", error);

          case 28:
            if (!((maxLength || minLength) && !isEmpty && isString(inputValue))) {
              _context.next = 38;
              break;
            }

            maxLengthOutput = getValueAndMessage(maxLength);
            minLengthOutput = getValueAndMessage(minLength);
            _exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;
            _exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;

            if (!(_exceedMax || _exceedMin)) {
              _context.next = 38;
              break;
            }

            getMinMaxMessage(_exceedMax, maxLengthOutput.message, minLengthOutput.message);

            if (validateAllFieldCriteria) {
              _context.next = 38;
              break;
            }

            setCustomValidity(error[name].message);
            return _context.abrupt("return", error);

          case 38:
            if (!(pattern && !isEmpty && isString(inputValue))) {
              _context.next = 45;
              break;
            }

            _getValueAndMessage = getValueAndMessage(pattern), patternValue = _getValueAndMessage.value, _message = _getValueAndMessage.message;

            if (!(isRegex(patternValue) && !inputValue.match(patternValue))) {
              _context.next = 45;
              break;
            }

            error[name] = Object.assign({
              type: INPUT_VALIDATION_RULES.pattern,
              message: _message,
              ref: ref
            }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, _message));

            if (validateAllFieldCriteria) {
              _context.next = 45;
              break;
            }

            setCustomValidity(_message);
            return _context.abrupt("return", error);

          case 45:
            if (!validate) {
              _context.next = 79;
              break;
            }

            if (!isFunction(validate)) {
              _context.next = 58;
              break;
            }

            _context.next = 49;
            return validate(inputValue);

          case 49:
            result = _context.sent;
            validateError = getValidateError(result, inputRef);

            if (!validateError) {
              _context.next = 56;
              break;
            }

            error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));

            if (validateAllFieldCriteria) {
              _context.next = 56;
              break;
            }

            setCustomValidity(validateError.message);
            return _context.abrupt("return", error);

          case 56:
            _context.next = 79;
            break;

          case 58:
            if (!isObject(validate)) {
              _context.next = 79;
              break;
            }

            validationResult = {};
            _context.t0 = _regeneratorRuntime.keys(validate);

          case 61:
            if ((_context.t1 = _context.t0()).done) {
              _context.next = 75;
              break;
            }

            key = _context.t1.value;

            if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {
              _context.next = 65;
              break;
            }

            return _context.abrupt("break", 75);

          case 65:
            _context.t2 = getValidateError;
            _context.next = 68;
            return validate[key](inputValue);

          case 68:
            _context.t3 = _context.sent;
            _context.t4 = inputRef;
            _context.t5 = key;
            _validateError = (0, _context.t2)(_context.t3, _context.t4, _context.t5);

            if (_validateError) {
              validationResult = Object.assign(Object.assign({}, _validateError), appendErrorsCurry(key, _validateError.message));
              setCustomValidity(_validateError.message);

              if (validateAllFieldCriteria) {
                error[name] = validationResult;
              }
            }

            _context.next = 61;
            break;

          case 75:
            if (isEmptyObject(validationResult)) {
              _context.next = 79;
              break;
            }

            error[name] = Object.assign({
              ref: inputRef
            }, validationResult);

            if (validateAllFieldCriteria) {
              _context.next = 79;
              break;
            }

            return _context.abrupt("return", error);

          case 79:
            setCustomValidity(true);
            return _context.abrupt("return", error);

          case 81:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function validateField(_x, _x2, _x3, _x4) {
    return _ref8.apply(this, arguments);
  };
}();

var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};

function createFormControl() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _options = Object.assign(Object.assign({}, defaultOptions), props);

  var _formState = {
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touchedFields: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    errors: {}
  };
  var _fields = {};

  var _defaultValues = _options.defaultValues || {};

  var _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);

  var _stateFlags = {
    action: false,
    mount: false,
    watch: false
  };
  var _names = {
    mount: new Set(),
    unMount: new Set(),
    array: new Set(),
    watch: new Set()
  };
  var delayErrorCallback;
  var timer = 0;
  var validateFields = {};
  var _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  var _subjects = {
    watch: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  var validationModeBeforeSubmit = getValidationModes(_options.mode);
  var validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  var shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;

  var debounce = function debounce(callback, wait) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      clearTimeout(timer);
      timer = window.setTimeout(function () {
        return callback.apply(void 0, args);
      }, wait);
    };
  };

  var _updateValid = /*#__PURE__*/function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(shouldSkipRender) {
      var isValid;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              isValid = false;

              if (!_proxyFormState.isValid) {
                _context2.next = 15;
                break;
              }

              if (!_options.resolver) {
                _context2.next = 10;
                break;
              }

              _context2.t1 = isEmptyObject;
              _context2.next = 6;
              return _executeSchema();

            case 6:
              _context2.t2 = _context2.sent.errors;
              _context2.t0 = (0, _context2.t1)(_context2.t2);
              _context2.next = 13;
              break;

            case 10:
              _context2.next = 12;
              return executeBuildInValidation(_fields, true);

            case 12:
              _context2.t0 = _context2.sent;

            case 13:
              isValid = _context2.t0;

              if (!shouldSkipRender && isValid !== _formState.isValid) {
                _formState.isValid = isValid;

                _subjects.state.next({
                  isValid: isValid
                });
              }

            case 15:
              return _context2.abrupt("return", isValid);

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function _updateValid(_x5) {
      return _ref10.apply(this, arguments);
    };
  }();

  var _updateFieldArray = function _updateFieldArray(name, method, args) {
    var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var shouldSetValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var shouldSetFields = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var shouldSetError = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
    _stateFlags.action = true;

    if (shouldSetFields && get(_fields, name)) {
      var fieldValues = method(get(_fields, name), args.argA, args.argB);
      shouldSetValues && set(_fields, name, fieldValues);
    }

    if (shouldSetError && Array.isArray(get(_formState.errors, name))) {
      var errors = method(get(_formState.errors, name), args.argA, args.argB);
      shouldSetValues && set(_formState.errors, name, errors);
      unsetEmptyArray(_formState.errors, name);
    }

    if (_proxyFormState.touchedFields && get(_formState.touchedFields, name)) {
      var touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
      shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      unsetEmptyArray(_formState.touchedFields, name);
    }

    if (_proxyFormState.dirtyFields || _proxyFormState.isDirty) {
      _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
    }

    _subjects.state.next({
      isDirty: _getDirty(name, values),
      dirtyFields: _formState.dirtyFields,
      errors: _formState.errors,
      isValid: _formState.isValid
    });
  };

  var updateErrors = function updateErrors(name, error) {
    return set(_formState.errors, name, error), _subjects.state.next({
      errors: _formState.errors
    });
  };

  var updateValidAndValue = function updateValidAndValue(name, shouldSkipSetValueAs, ref) {
    var field = get(_fields, name);

    if (field) {
      var defaultValue = get(_formValues, name, get(_defaultValues, name));
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
    }

    _stateFlags.mount && _updateValid();
  };

  var updateTouchAndDirty = function updateTouchAndDirty(name, fieldValue, isCurrentTouched) {
    var shouldRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var isFieldDirty = false;
    var output = {
      name: name
    };
    var isPreviousFieldTouched = get(_formState.touchedFields, name);

    if (_proxyFormState.isDirty) {
      var isPreviousFormDirty = _formState.isDirty;
      _formState.isDirty = output.isDirty = _getDirty();
      isFieldDirty = isPreviousFormDirty !== output.isDirty;
    }

    if (_proxyFormState.dirtyFields && !isCurrentTouched) {
      var isPreviousFieldDirty = get(_formState.dirtyFields, name);
      var isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
      isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      isFieldDirty = isFieldDirty || isPreviousFieldDirty !== get(_formState.dirtyFields, name);
    }

    if (isCurrentTouched && !isPreviousFieldTouched) {
      set(_formState.touchedFields, name, isCurrentTouched);
      output.touchedFields = _formState.touchedFields;
      isFieldDirty = isFieldDirty || _proxyFormState.touchedFields && isPreviousFieldTouched !== isCurrentTouched;
    }

    isFieldDirty && shouldRender && _subjects.state.next(output);
    return isFieldDirty ? output : {};
  };

  var shouldRenderByError = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(shouldSkipRender, name, isValid, error, fieldState) {
      var previousFieldError, shouldUpdateValid, updatedFormState;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              previousFieldError = get(_formState.errors, name);
              shouldUpdateValid = _proxyFormState.isValid && _formState.isValid !== isValid;

              if (props.delayError && error) {
                delayErrorCallback = delayErrorCallback || debounce(updateErrors, props.delayError);
                delayErrorCallback(name, error);
              } else {
                clearTimeout(timer);
                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
              }

              if (((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) && !shouldSkipRender) {
                updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), shouldUpdateValid ? {
                  isValid: isValid
                } : {}), {
                  errors: _formState.errors,
                  name: name
                });
                _formState = Object.assign(Object.assign({}, _formState), updatedFormState);

                _subjects.state.next(updatedFormState);
              }

              validateFields[name]--;

              if (_proxyFormState.isValidating && !validateFields[name]) {
                _subjects.state.next({
                  isValidating: false
                });

                validateFields = {};
              }

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function shouldRenderByError(_x6, _x7, _x8, _x9, _x10) {
      return _ref11.apply(this, arguments);
    };
  }();

  var _executeSchema = /*#__PURE__*/function () {
    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(name) {
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!_options.resolver) {
                _context4.next = 6;
                break;
              }

              _context4.next = 3;
              return _options.resolver(Object.assign({}, _formValues), _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));

            case 3:
              _context4.t0 = _context4.sent;
              _context4.next = 7;
              break;

            case 6:
              _context4.t0 = {};

            case 7:
              return _context4.abrupt("return", _context4.t0);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function _executeSchema(_x11) {
      return _ref12.apply(this, arguments);
    };
  }();

  var executeSchemaAndUpdateState = /*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(names) {
      var _yield$_executeSchema, errors, _iterator5, _step5, _name2, _error;

      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _executeSchema();

            case 2:
              _yield$_executeSchema = _context5.sent;
              errors = _yield$_executeSchema.errors;

              if (names) {
                _iterator5 = _createForOfIteratorHelper(names);

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    _name2 = _step5.value;
                    _error = get(errors, _name2);
                    _error ? set(_formState.errors, _name2, _error) : unset(_formState.errors, _name2);
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
              } else {
                _formState.errors = errors;
              }

              return _context5.abrupt("return", errors);

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function executeSchemaAndUpdateState(_x12) {
      return _ref13.apply(this, arguments);
    };
  }();

  var executeBuildInValidation = /*#__PURE__*/function () {
    var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(fields, shouldOnlyCheckValid) {
      var context,
          _name3,
          field,
          fieldReference,
          fieldValue,
          fieldError,
          _args6 = arguments;

      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              context = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {
                valid: true
              };
              _context6.t0 = _regeneratorRuntime.keys(fields);

            case 2:
              if ((_context6.t1 = _context6.t0()).done) {
                _context6.next = 23;
                break;
              }

              _name3 = _context6.t1.value;
              field = fields[_name3];

              if (!field) {
                _context6.next = 21;
                break;
              }

              fieldReference = field._f;
              fieldValue = omit(field, '_f');

              if (!fieldReference) {
                _context6.next = 17;
                break;
              }

              _context6.next = 11;
              return validateField(field, get(_formValues, fieldReference.name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation);

            case 11:
              fieldError = _context6.sent;

              if (!fieldError[fieldReference.name]) {
                _context6.next = 16;
                break;
              }

              context.valid = false;

              if (!shouldOnlyCheckValid) {
                _context6.next = 16;
                break;
              }

              return _context6.abrupt("break", 23);

            case 16:
              if (!shouldOnlyCheckValid) {
                fieldError[fieldReference.name] ? set(_formState.errors, fieldReference.name, fieldError[fieldReference.name]) : unset(_formState.errors, fieldReference.name);
              }

            case 17:
              _context6.t2 = fieldValue;

              if (!_context6.t2) {
                _context6.next = 21;
                break;
              }

              _context6.next = 21;
              return executeBuildInValidation(fieldValue, shouldOnlyCheckValid, context);

            case 21:
              _context6.next = 2;
              break;

            case 23:
              return _context6.abrupt("return", context.valid);

            case 24:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function executeBuildInValidation(_x13, _x14) {
      return _ref14.apply(this, arguments);
    };
  }();

  var _removeUnmounted = function _removeUnmounted() {
    var _iterator6 = _createForOfIteratorHelper(_names.unMount),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _name4 = _step6.value;
        var field = get(_fields, _name4);
        field && (field._f.refs ? field._f.refs.every(function (ref) {
          return !live(ref);
        }) : !live(field._f.ref)) && unregister(_name4);
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    _names.unMount = new Set();
  };

  var _getDirty = function _getDirty(name, data) {
    return name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues);
  };

  var _getWatch = function _getWatch(names, defaultValue, isGlobal) {
    var fieldValues = Object.assign({}, _stateFlags.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? _defineProperty({}, names, defaultValue) : defaultValue);
    return generateWatchOutput(names, _names, fieldValues, isGlobal);
  };

  var _getFieldArray = function _getFieldArray(name) {
    return compact(get(_stateFlags.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  };

  var setFieldValue = function setFieldValue(name, value) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var field = get(_fields, name);
    var fieldValue = value;

    if (field) {
      var fieldReference = field._f;

      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isWeb && isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? '' : value;

        if (isMultipleSelect(fieldReference.ref)) {
          _toConsumableArray(fieldReference.ref.options).forEach(function (selectRef) {
            return selectRef.selected = fieldValue.includes(selectRef.value);
          });
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach(function (checkboxRef) {
              return checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find(function (data) {
                return data === checkboxRef.value;
              }) : fieldValue === checkboxRef.value;
            }) : fieldReference.refs[0].checked = !!fieldValue;
          } else {
            fieldReference.refs.forEach(function (radioRef) {
              return radioRef.checked = radioRef.value === fieldValue;
            });
          }
        } else if (!isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = fieldValue;

          if (!fieldReference.ref.type) {
            _subjects.watch.next({
              name: name
            });
          }
        }
      }
    }

    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch);
    options.shouldValidate && trigger(name);
  };

  var setValues = function setValues(name, value, options) {
    for (var fieldKey in value) {
      var fieldValue = value[fieldKey];
      var fieldName = "".concat(name, ".").concat(fieldKey);
      var field = get(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };

  var setValue = function setValue(name, value) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var field = get(_fields, name);

    var isFieldArray = _names.array.has(name);

    set(_formValues, name, value);

    if (isFieldArray) {
      _subjects.array.next({
        name: name,
        values: _formValues
      });

      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);

        _subjects.state.next({
          name: name,
          dirtyFields: _formState.dirtyFields,
          isDirty: _getDirty(name, value)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(value) ? setValues(name, value, options) : setFieldValue(name, value, options);
    }

    isWatched(name, _names) && _subjects.state.next({});

    _subjects.watch.next({
      name: name
    });
  };

  var onChange = /*#__PURE__*/function () {
    var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(event) {
      var target, name, field, _error2, isValid, fieldValue, isBlurEvent, shouldSkipValidation, watched, fieldState, shouldRender, _yield$_executeSchema2, errors, previousErrorLookupResult, errorLookupResult;

      return _regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              target = event.target;
              name = target.name;
              field = get(_fields, name);

              if (!field) {
                _context7.next = 39;
                break;
              }

              fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
              isBlurEvent = event.type === EVENTS.BLUR;
              shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
              watched = isWatched(name, _names, isBlurEvent);

              if (isBlurEvent) {
                field._f.onBlur && field._f.onBlur(event);
              } else if (field._f.onChange) {
                field._f.onChange(event);
              }

              set(_formValues, name, fieldValue);
              fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
              shouldRender = !isEmptyObject(fieldState) || watched;
              !isBlurEvent && _subjects.watch.next({
                name: name,
                type: event.type
              });

              if (!shouldSkipValidation) {
                _context7.next = 15;
                break;
              }

              return _context7.abrupt("return", shouldRender && _subjects.state.next(Object.assign({
                name: name
              }, watched ? {} : fieldState)));

            case 15:
              !isBlurEvent && watched && _subjects.state.next({});
              validateFields[name] = validateFields[name] ? +1 : 1;
              _proxyFormState.isValidating && _subjects.state.next({
                isValidating: true
              });

              if (!_options.resolver) {
                _context7.next = 30;
                break;
              }

              _context7.next = 21;
              return _executeSchema([name]);

            case 21:
              _yield$_executeSchema2 = _context7.sent;
              errors = _yield$_executeSchema2.errors;
              previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
              errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
              _error2 = errorLookupResult.error;
              name = errorLookupResult.name;
              isValid = isEmptyObject(errors);
              _context7.next = 37;
              break;

            case 30:
              _context7.next = 32;
              return validateField(field, get(_formValues, name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation);

            case 32:
              _context7.t0 = name;
              _error2 = _context7.sent[_context7.t0];
              _context7.next = 36;
              return _updateValid(true);

            case 36:
              isValid = _context7.sent;

            case 37:
              field._f.deps && trigger(field._f.deps);
              shouldRenderByError(false, name, isValid, _error2, fieldState);

            case 39:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function onChange(_x15) {
      return _ref16.apply(this, arguments);
    };
  }();

  var trigger = /*#__PURE__*/function () {
    var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(name) {
      var options,
          isValid,
          validationResult,
          fieldNames,
          errors,
          _args9 = arguments;
      return _regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
              fieldNames = convertToArrayPayload(name);

              _subjects.state.next({
                isValidating: true
              });

              if (!_options.resolver) {
                _context9.next = 11;
                break;
              }

              _context9.next = 6;
              return executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);

            case 6:
              errors = _context9.sent;
              isValid = isEmptyObject(errors);
              validationResult = name ? !fieldNames.some(function (name) {
                return get(errors, name);
              }) : isValid;
              _context9.next = 21;
              break;

            case 11:
              if (!name) {
                _context9.next = 18;
                break;
              }

              _context9.next = 14;
              return Promise.all(fieldNames.map( /*#__PURE__*/function () {
                var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(fieldName) {
                  var field;
                  return _regeneratorRuntime.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          field = get(_fields, fieldName);
                          _context8.next = 3;
                          return executeBuildInValidation(field && field._f ? _defineProperty({}, fieldName, field) : field);

                        case 3:
                          return _context8.abrupt("return", _context8.sent);

                        case 4:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                }));

                return function (_x17) {
                  return _ref18.apply(this, arguments);
                };
              }()));

            case 14:
              validationResult = _context9.sent.every(Boolean);
              !(!validationResult && !_formState.isValid) && _updateValid();
              _context9.next = 21;
              break;

            case 18:
              _context9.next = 20;
              return executeBuildInValidation(_fields);

            case 20:
              validationResult = isValid = _context9.sent;

            case 21:
              _subjects.state.next(Object.assign(Object.assign(Object.assign({}, !isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {
                name: name
              }), _options.resolver ? {
                isValid: isValid
              } : {}), {
                errors: _formState.errors,
                isValidating: false
              }));

              options.shouldFocus && !validationResult && focusFieldBy(_fields, function (key) {
                return get(_formState.errors, key);
              }, name ? fieldNames : _names.mount);
              return _context9.abrupt("return", validationResult);

            case 24:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    return function trigger(_x16) {
      return _ref17.apply(this, arguments);
    };
  }();

  var getValues = function getValues(fieldNames) {
    var values = Object.assign(Object.assign({}, _defaultValues), _stateFlags.mount ? _formValues : {});
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map(function (name) {
      return get(values, name);
    });
  };

  var clearErrors = function clearErrors(name) {
    name ? convertToArrayPayload(name).forEach(function (inputName) {
      return unset(_formState.errors, inputName);
    }) : _formState.errors = {};

    _subjects.state.next({
      errors: _formState.errors,
      isValid: true
    });
  };

  var setError = function setError(name, error, options) {
    var ref = (get(_fields, name, {
      _f: {}
    })._f || {}).ref;
    set(_formState.errors, name, Object.assign(Object.assign({}, error), {
      ref: ref
    }));

    _subjects.state.next({
      name: name,
      errors: _formState.errors,
      isValid: false
    });

    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };

  var watch = function watch(name, defaultValue) {
    return isFunction(name) ? _subjects.watch.subscribe({
      next: function next(info) {
        return name(_getWatch(undefined, defaultValue), info);
      }
    }) : _getWatch(name, defaultValue, true);
  };

  var unregister = function unregister(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _iterator7 = _createForOfIteratorHelper(name ? convertToArrayPayload(name) : _names.mount),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var fieldName = _step7.value;

        _names.mount.delete(fieldName);

        _names.array.delete(fieldName);

        if (get(_fields, fieldName)) {
          if (!options.keepValue) {
            unset(_fields, fieldName);
            unset(_formValues, fieldName);
          }

          !options.keepError && unset(_formState.errors, fieldName);
          !options.keepDirty && unset(_formState.dirtyFields, fieldName);
          !options.keepTouched && unset(_formState.touchedFields, fieldName);
          !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    _subjects.watch.next({});

    _subjects.state.next(Object.assign(Object.assign({}, _formState), !options.keepDirty ? {} : {
      isDirty: _getDirty()
    }));

    !options.keepIsValid && _updateValid();
  };

  var register = function register(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var field = get(_fields, name);
    set(_fields, name, {
      _f: Object.assign(Object.assign(Object.assign({}, field && field._f ? field._f : {
        ref: {
          name: name
        }
      }), {
        name: name,
        mount: true
      }), options)
    });

    _names.mount.add(name);

    !isUndefined(options.value) && !options.disabled && set(_formValues, name, get(_formValues, name, options.value));
    field ? isBoolean(options.disabled) && set(_formValues, name, options.disabled ? undefined : get(_formValues, name, getFieldValue(field._f))) : updateValidAndValue(name, true);
    return Object.assign(Object.assign(Object.assign({}, isBoolean(options.disabled) ? {
      disabled: options.disabled
    } : {}), _options.shouldUseNativeValidation ? {
      required: !!options.required,
      min: getRuleValue(options.min),
      max: getRuleValue(options.max),
      minLength: getRuleValue(options.minLength),
      maxLength: getRuleValue(options.maxLength),
      pattern: getRuleValue(options.pattern)
    } : {}), {
      name: name,
      onChange: onChange,
      onBlur: onChange,
      ref: function (_ref20) {
        function ref(_x18) {
          return _ref20.apply(this, arguments);
        }

        ref.toString = function () {
          return _ref20.toString();
        };

        return ref;
      }(function (ref) {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          var fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll('input,select,textarea')[0] || ref : ref : ref;
          var radioOrCheckbox = isRadioOrCheckbox(fieldRef);

          if (fieldRef === field._f.ref || radioOrCheckbox && compact(field._f.refs).find(function (option) {
            return option === fieldRef;
          })) {
            return;
          }

          set(_fields, name, {
            _f: radioOrCheckbox ? Object.assign(Object.assign({}, field._f), {
              refs: [].concat(_toConsumableArray(compact(field._f.refs).filter(live)), [fieldRef]),
              ref: {
                type: fieldRef.type,
                name: name
              }
            }) : Object.assign(Object.assign({}, field._f), {
              ref: fieldRef
            })
          });
          updateValidAndValue(name, false, fieldRef);
        } else {
          field = get(_fields, name, {});

          if (field._f) {
            field._f.mount = false;
          }

          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _stateFlags.action) && _names.unMount.add(name);
        }
      })
    });
  };

  var handleSubmit = function handleSubmit(onValid, onInvalid) {
    return /*#__PURE__*/function () {
      var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(e) {
        var hasNoPromiseError, fieldValues, _yield$_executeSchema3, errors, values;

        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (e) {
                  e.preventDefault && e.preventDefault();
                  e.persist && e.persist();
                }

                hasNoPromiseError = true;
                fieldValues = _options.shouldUnregister ? cloneObject(_formValues) : Object.assign({}, _formValues);

                _subjects.state.next({
                  isSubmitting: true
                });

                _context10.prev = 4;

                if (!_options.resolver) {
                  _context10.next = 15;
                  break;
                }

                _context10.next = 8;
                return _executeSchema();

              case 8:
                _yield$_executeSchema3 = _context10.sent;
                errors = _yield$_executeSchema3.errors;
                values = _yield$_executeSchema3.values;
                _formState.errors = errors;
                fieldValues = values;
                _context10.next = 17;
                break;

              case 15:
                _context10.next = 17;
                return executeBuildInValidation(_fields);

              case 17:
                if (!(isEmptyObject(_formState.errors) && Object.keys(_formState.errors).every(function (name) {
                  return get(fieldValues, name);
                }))) {
                  _context10.next = 23;
                  break;
                }

                _subjects.state.next({
                  errors: {},
                  isSubmitting: true
                });

                _context10.next = 21;
                return onValid(fieldValues, e);

              case 21:
                _context10.next = 28;
                break;

              case 23:
                _context10.t0 = onInvalid;

                if (!_context10.t0) {
                  _context10.next = 27;
                  break;
                }

                _context10.next = 27;
                return onInvalid(_formState.errors, e);

              case 27:
                _options.shouldFocusError && focusFieldBy(_fields, function (key) {
                  return get(_formState.errors, key);
                }, _names.mount);

              case 28:
                _context10.next = 34;
                break;

              case 30:
                _context10.prev = 30;
                _context10.t1 = _context10["catch"](4);
                hasNoPromiseError = false;
                throw _context10.t1;

              case 34:
                _context10.prev = 34;
                _formState.isSubmitted = true;

                _subjects.state.next({
                  isSubmitted: true,
                  isSubmitting: false,
                  isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,
                  submitCount: _formState.submitCount + 1,
                  errors: _formState.errors
                });

                return _context10.finish(34);

              case 38:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[4, 30, 34, 38]]);
      }));

      return function (_x19) {
        return _ref21.apply(this, arguments);
      };
    }();
  };

  var resetField = function resetField(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (isUndefined(options.defaultValue)) {
      setValue(name, get(_defaultValues, name));
    } else {
      setValue(name, options.defaultValue);
      set(_defaultValues, name, options.defaultValue);
    }

    if (!options.keepTouched) {
      unset(_formState.touchedFields, name);
    }

    if (!options.keepDirty) {
      unset(_formState.dirtyFields, name);
      _formState.isDirty = options.defaultValue ? _getDirty(name, get(_defaultValues, name)) : _getDirty();
    }

    if (!options.keepError) {
      unset(_formState.errors, name);
      _proxyFormState.isValid && _updateValid();
    }

    _subjects.state.next(Object.assign({}, _formState));
  };

  var reset = function reset(formValues) {
    var keepStateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var updatedValues = formValues || _defaultValues;
    var cloneUpdatedValues = cloneObject(updatedValues);
    var values = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;

    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }

    if (!keepStateOptions.keepValues) {
      if (isWeb && isUndefined(formValues)) {
        var _iterator8 = _createForOfIteratorHelper(_names.mount),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _name5 = _step8.value;
            var field = get(_fields, _name5);

            if (field && field._f) {
              var fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;

              try {
                isHTMLElement(fieldReference) && fieldReference.closest('form').reset();
                break;
              } catch (_a) {}
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }

      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneUpdatedValues;
      _fields = {};

      _subjects.array.next({
        values: values
      });

      _subjects.watch.next({
        values: values
      });
    }

    _names = {
      mount: new Set(),
      unMount: new Set(),
      array: new Set(),
      watch: new Set(),
      watchAll: false,
      focus: ''
    };
    _stateFlags.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;
    _stateFlags.watch = !!props.shouldUnregister;

    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: keepStateOptions.keepDirty ? _formState.isDirty : keepStateOptions.keepDefaultValues ? !deepEqual(formValues, _defaultValues) : false,
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: keepStateOptions.keepDirty ? _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? Object.entries(formValues).reduce(function (previous, _ref22) {
        var _ref23 = _slicedToArray(_ref22, 2),
            key = _ref23[0],
            value = _ref23[1];

        return Object.assign(Object.assign({}, previous), _defineProperty({}, key, value !== get(_defaultValues, key)));
      }, {}) : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  };

  var setFocus = function setFocus(name) {
    var field = get(_fields, name)._f;

    (field.ref.focus ? field.ref : field.refs[0]).focus();
  };

  return {
    control: {
      register: register,
      unregister: unregister,
      _executeSchema: _executeSchema,
      _getWatch: _getWatch,
      _getDirty: _getDirty,
      _updateValid: _updateValid,
      _removeUnmounted: _removeUnmounted,
      _updateFieldArray: _updateFieldArray,
      _getFieldArray: _getFieldArray,
      _subjects: _subjects,
      _proxyFormState: _proxyFormState,

      get _fields() {
        return _fields;
      },

      set _fields(value) {
        _fields = value;
      },

      get _formValues() {
        return _formValues;
      },

      set _formValues(value) {
        _formValues = value;
      },

      get _stateFlags() {
        return _stateFlags;
      },

      set _stateFlags(value) {
        _stateFlags = value;
      },

      get _defaultValues() {
        return _defaultValues;
      },

      set _defaultValues(value) {
        _defaultValues = value;
      },

      get _names() {
        return _names;
      },

      set _names(value) {
        _names = value;
      },

      get _formState() {
        return _formState;
      },

      set _formState(value) {
        _formState = value;
      },

      get _options() {
        return _options;
      },

      set _options(value) {
        _options = Object.assign(Object.assign({}, _options), value);
      }

    },
    trigger: trigger,
    register: register,
    handleSubmit: handleSubmit,
    watch: watch,
    setValue: setValue,
    getValues: getValues,
    reset: reset,
    resetField: resetField,
    clearErrors: clearErrors,
    unregister: unregister,
    setError: setError,
    setFocus: setFocus
  };
}

function useForm() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _formControl = React.useRef();

  var _React$useState7 = React.useState({
    isDirty: false,
    isValidating: false,
    dirtyFields: {},
    isSubmitted: false,
    submitCount: 0,
    touchedFields: {},
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    errors: {}
  }),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      formState = _React$useState8[0],
      updateFormState = _React$useState8[1];

  if (_formControl.current) {
    _formControl.current.control._options = props;
  } else {
    _formControl.current = Object.assign(Object.assign({}, createFormControl(props)), {
      formState: formState
    });
  }

  var control = _formControl.current.control;
  useSubscribe({
    subject: control._subjects.state,
    callback: function callback(value) {
      if (shouldRenderFormState(value, control._proxyFormState, true)) {
        control._formState = Object.assign(Object.assign({}, control._formState), value);
        updateFormState(Object.assign({}, control._formState));
      }
    }
  });
  React.useEffect(function () {
    if (!control._stateFlags.mount) {
      control._proxyFormState.isValid && control._updateValid();
      control._stateFlags.mount = true;
    }

    if (control._stateFlags.watch) {
      control._stateFlags.watch = false;

      control._subjects.state.next({});
    }

    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);
  return _formControl.current;
}

export { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };